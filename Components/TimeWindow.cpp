//
//    filename: description
//    Copyright (C) 2018 Gonzalo José Carracedo Carballal
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Lesser General Public License as
//    published by the Free Software Foundation, either version 3 of the
//    License, or (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this program.  If not, see
//    <http://www.gnu.org/licenses/>
//
#include <TimeWindow.h>
#include <QFileDialog>
#include <QMessageBox>
#include <fstream>
#include <iomanip>
#include "ui_TimeWindow.h"
#include <climits>

bool
TimeWindow::exportToFile(QString const &path, int start, int end)
{
  std::ofstream of(path.toStdString().c_str(), std::ofstream::binary);
  const SUCOMPLEX *data = this->ui->realWaveform->getData();
  int length = static_cast<int>(this->ui->realWaveform->getDataLength());

  if (!of.is_open())
    return false;

  of << "%\n";
  of << "% Time domain capture file generated by SigDigger\n";
  of << "%\n\n";

  of << "sampleRate = " << this->ui->realWaveform->getSampleRate() << ";\n";
  of << "deltaT = " << 1 / this->ui->realWaveform->getSampleRate() << ";\n";
  of << "X = [ ";

  of << std::setprecision(std::numeric_limits<float>::digits10);

  if (start < 0)
    start = 0;
  if (end >= length)
    end = length - 1;

  for (int i = start; i <= end; ++i)
    of << SU_C_REAL(data[i]) << " + " << SU_C_IMAG(data[i]) << "i, ";

  of << "];\n";

  return true;
}

void
TimeWindow::connectAll(void)
{
  connect(
        this->ui->realWaveform,
        SIGNAL(horizontalRangeChanged(qint64, qint64)),
        this,
        SLOT(onHZoom(qint64, qint64)));

  connect(
        this->ui->realWaveform,
        SIGNAL(horizontalSelectionChanged(qreal, qreal)),
        this,
        SLOT(onHSelection(qreal, qreal)));

  connect(
        this->ui->imagWaveform,
        SIGNAL(horizontalRangeChanged(qint64, qint64)),
        this,
        SLOT(onHZoom(qint64, qint64)));

  connect(
        this->ui->imagWaveform,
        SIGNAL(horizontalSelectionChanged(qreal, qreal)),
        this,
        SLOT(onHSelection(qreal, qreal)));

  connect(
        this->ui->realWaveform,
        SIGNAL(hoverTime(qreal)),
        this,
        SLOT(onHoverTime(qreal)));

  connect(
        this->ui->imagWaveform,
        SIGNAL(hoverTime(qreal)),
        this,
        SLOT(onHoverTime(qreal)));

  connect(
        this->ui->actionSave,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onSaveAll(void)));

  connect(
        this->ui->actionSave_selection,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onSaveSelection(void)));

  connect(
        this->ui->actionFit_to_gain,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onFit(void)));

  connect(
        this->ui->actionHorizontal_selection,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onToggleHorizontalSelection(void)));

  connect(
        this->ui->actionVertical_selection,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onToggleVerticalSelection(void)));

  connect(
        this->ui->actionZoom_selection,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onZoomToSelection(void)));

  connect(
        this->ui->actionResetZoom,
        SIGNAL(triggered(bool)),
        this,
        SLOT(onZoomReset(void)));

  connect(
        this->ui->periodicSelectionCheck,
        SIGNAL(stateChanged(int)),
        this,
        SLOT(onTogglePeriodicSelection(void)));

  connect(
        this->ui->periodicDivisionsSpin,
        SIGNAL(valueChanged(int)),
        this,
        SLOT(onPeriodicDivisionsChanged(void)));
}

int
TimeWindow::getPeriodicDivision(void) const
{
  return this->ui->periodicDivisionsSpin->value();
}

void
TimeWindow::kahanMeanAndRms(
    SUCOMPLEX *mean,
    SUFLOAT *rms,
    const SUCOMPLEX *data,
    int length)
{
  SUCOMPLEX meanSum = 0;
  SUCOMPLEX meanC   = 0;
  SUCOMPLEX meanY, meanT;

  SUFLOAT   rmsSum = 0;
  SUFLOAT   rmsC   = 0;
  SUFLOAT   rmsY, rmsT;

  for (int i = 0; i < length; ++i) {
    meanY = data[i] - meanC;
    rmsY  = SU_C_REAL(data[i] * SU_C_CONJ(data[i])) - rmsC;

    meanT = meanSum + meanY;
    rmsT  = rmsSum  + rmsY;

    meanC = (meanT - meanSum) - meanY;
    rmsC  = (rmsT  - rmsSum)  - rmsY;

    meanSum = meanT;
    rmsSum  = rmsT;
  }

  *mean = meanSum / length;
  *rms  = SU_SQRT(rmsSum / length);
}

void
TimeWindow::calcLimits(
    SUCOMPLEX *oMin,
    SUCOMPLEX *oMax,
    const SUCOMPLEX *data,
    int length)
{
  SUFLOAT minReal = +std::numeric_limits<SUFLOAT>::infinity();
  SUFLOAT maxReal = -std::numeric_limits<SUFLOAT>::infinity();
  SUFLOAT minImag = minReal;
  SUFLOAT maxImag = maxReal;

  for (int i = 0; i < length; ++i) {
    if (SU_C_REAL(data[i]) < minReal)
      minReal = SU_C_REAL(data[i]);
    if (SU_C_IMAG(data[i]) < minImag)
      minImag = SU_C_IMAG(data[i]);

    if (SU_C_REAL(data[i]) > maxReal)
      maxReal = SU_C_REAL(data[i]);
    if (SU_C_IMAG(data[i]) > maxImag)
      maxImag = SU_C_IMAG(data[i]);
  }

  *oMin = minReal + I * minImag;
  *oMax = maxReal + I * maxImag;
}

void
TimeWindow::recalcLimits(void)
{
  const SUCOMPLEX *data = this->ui->realWaveform->getData();
  int length = static_cast<int>(this->ui->realWaveform->getDataLength());

  if (length == 0) {
    this->min = this->max = this->mean = this->rms = 0;
  } else {
    kahanMeanAndRms(&this->mean, &this->rms, data, length);
    calcLimits(&this->min, &this->max, data, length);
  }
}

void
TimeWindow::refreshUi(void)
{
  bool haveSelection = this->ui->realWaveform->getHorizontalSelectionPresent();
  this->ui->periodicDivisionsSpin->setEnabled(
        this->ui->periodicSelectionCheck->isChecked());
  this->ui->selStartLabel->setEnabled(haveSelection);
  this->ui->selEndLabel->setEnabled(haveSelection);
  this->ui->selLengthLabel->setEnabled(haveSelection);
  this->ui->periodLabel->setEnabled(haveSelection);
  this->ui->baudLabel->setEnabled(haveSelection);
  this->ui->actionSave_selection->setEnabled(haveSelection);
  this->ui->sampleRateLabel->setText(
        QString::number(static_cast<int>(
          this->ui->realWaveform->getSampleRate())));
}

void
TimeWindow::refreshMeasures(void)
{
  qreal selStart = 0;
  qreal selEnd   = 0;
  qreal deltaT = 1. / this->ui->realWaveform->getSampleRate();
  SUCOMPLEX min, max, mean;
  SUFLOAT rms;
  const SUCOMPLEX *data = this->ui->realWaveform->getData();
  int length = static_cast<int>(this->ui->realWaveform->getDataLength());

  if (this->ui->realWaveform->getHorizontalSelectionPresent()) {
    selStart = this->ui->realWaveform->getHorizontalSelectionStart();
    selEnd   = this->ui->realWaveform->getHorizontalSelectionEnd();

    if (selStart < 0)
      selStart = 0;
    if (selEnd > length)
      selEnd = length;
  }

  if (selEnd - selStart > 0) {
    qreal period =
        (selEnd - selStart) /
        (this->ui->periodicSelectionCheck->isChecked()
           ? this->getPeriodicDivision()
           : 1)
        * deltaT;
    qreal baud = 1 / period;

    kahanMeanAndRms(
          &mean,
          &rms,
          data + static_cast<qint64>(selStart),
          static_cast<int>(selEnd - selStart));
    calcLimits(
          &min,
          &max,
          data + static_cast<qint64>(selStart),
          static_cast<int>(selEnd - selStart));

    this->ui->periodLabel->setText(Waveform::formatLabel(period, "s"));
    this->ui->baudLabel->setText(formatReal(baud));
    this->ui->selStartLabel->setText(
          Waveform::formatLabel(
            this->ui->realWaveform->samp2t(selStart),
            "s")
          + " (" + formatReal(selStart) + ")");
    this->ui->selEndLabel->setText(
          Waveform::formatLabel(
            this->ui->realWaveform->samp2t(selEnd),
            "s")
          + " (" + formatReal(selEnd) + ")");
    this->ui->selLengthLabel->setText(
          Waveform::formatLabel(
            (selEnd - selStart) * deltaT,
            "s")
          + " (" + formatReal(selEnd - selStart) + ")");
  } else {
    min = this->min;
    max = this->max;
    mean = this->mean;
    rms = this->rms;
    this->ui->periodLabel->setText("N/A");
    this->ui->baudLabel->setText("N/A");
    this->ui->selStartLabel->setText("N/A");
    this->ui->selEndLabel->setText("N/A");
    this->ui->selLengthLabel->setText("N/A");
  }

  this->ui->lengthLabel->setText(QString::number(length) + " samples");
  this->ui->durationLabel->setText(Waveform::formatLabel(length * deltaT, "s"));
  this->ui->limitsLabel->setText(formatComplex(min) + " / " + formatComplex(max));
  this->ui->meanLabel->setText(formatComplex(mean));
  this->ui->rmsLabel->setText(formatScientific(rms));
}

void
TimeWindow::setData(std::vector<SUCOMPLEX> const &data, qreal fs)
{
  this->ui->realWaveform->setData(&data);
  this->ui->realWaveform->setSampleRate(fs);

  this->ui->imagWaveform->setData(&data);
  this->ui->imagWaveform->setSampleRate(fs);

  this->recalcLimits();

  this->refreshUi();
  this->refreshMeasures();
  this->onFit();
}

TimeWindow::TimeWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::TimeWindow)
{
  ui->setupUi(this);

  this->ui->realWaveform->setRealComponent(true);
  this->ui->imagWaveform->setRealComponent(false);

  this->recalcLimits();

  this->refreshUi();
  this->refreshMeasures();

  this->connectAll();
}

TimeWindow::~TimeWindow()
{
  delete ui;
}

//////////////////////////////////// Slots /////////////////////////////////////
void
TimeWindow::onHZoom(qint64 min, qint64 max)
{
  QObject* obj = sender();

  if (!this->adjusting) {
    Waveform *wf = nullptr;
    this->adjusting = true;

    if (obj == this->ui->realWaveform)
      wf = this->ui->imagWaveform;
    else
      wf = this->ui->realWaveform;

    wf->zoomHorizontal(min, max);
    wf->invalidate();
    this->adjusting = false;
  }
}

void
TimeWindow::onVZoom(qreal, qreal)
{
  // QObject* obj = sender();
}

void
TimeWindow::onHSelection(qreal min, qreal max)
{
  QObject *obj = sender();

  if (!this->adjusting) {
    Waveform *curr = static_cast<Waveform *>(obj);
    Waveform *wf;
    this->adjusting = true;

    if (obj == this->ui->realWaveform)
      wf = this->ui->imagWaveform;
    else
      wf = this->ui->realWaveform;

    if (curr->getHorizontalSelectionPresent())
      wf->selectHorizontal(min, max);
    else
      wf->selectHorizontal(0, 0);

    this->refreshUi();
    this->refreshMeasures();
    wf->invalidate();

    this->adjusting = false;
  }
}

void
TimeWindow::onVSelection(qreal, qreal)
{
  // QObject* obj = sender();
}

QString
TimeWindow::formatComplex(SUCOMPLEX const &val)
{
  return formatReal(SU_C_REAL(val))
  + (SU_C_IMAG(val) < 0
     ? " - " + formatReal(-SU_C_IMAG(val))
     : " + " + formatReal(SU_C_IMAG(val))) + "i";
}

QString
TimeWindow::formatScientific(qreal real)
{
  char string[32];

  snprintf(string, 32, "%+-30.6e", real);

  return QString(string);
}

QString
TimeWindow::formatReal(qreal real)
{
  char string[32];

  snprintf(string, 32, "%g", real);

  return QString(string);
}

void
TimeWindow::onHoverTime(qreal time)
{
  const SUCOMPLEX *data = this->ui->realWaveform->getData();
  int length = static_cast<int>(this->ui->realWaveform->getDataLength());
  qreal samp = this->ui->realWaveform->t2samp(time);
  qint64 iSamp = static_cast<qint64>(std::floor(samp));
  qreal max = std::max<qreal>(
        std::max<qreal>(
          std::fabs(this->ui->realWaveform->getMax()),
          std::fabs(this->ui->realWaveform->getMin())),
        std::max<qreal>(
          std::fabs(this->ui->imagWaveform->getMax()),
          std::fabs(this->ui->imagWaveform->getMin())));

  qreal ampl = 1;
  if (max > 0)
    ampl = 1. / max;

  if (iSamp < 0)
    samp = iSamp = 0;
  if (iSamp > length)
    samp = iSamp = length - 1;

  SUFLOAT t = static_cast<SUFLOAT>(samp - iSamp);
  SUCOMPLEX val = (1 - t) * data[iSamp] + t * data[iSamp + 1];

  this->ui->constellation->setGain(ampl);

  if (this->ui->realWaveform->getHorizontalSelectionPresent()) {
    qint64 selStart = static_cast<qint64>(
          this->ui->realWaveform->getHorizontalSelectionStart());
    qint64 selEnd = static_cast<qint64>(
          this->ui->realWaveform->getHorizontalSelectionEnd());

    if (selStart < 0)
      selStart = 0;
    if (selEnd > length)
      selEnd = length;

    if (selEnd - selStart > TIME_WINDOW_MAX_SELECTION)
      selStart = selEnd - TIME_WINDOW_MAX_SELECTION;

    if (selEnd - selStart > 0) {
      this->ui->constellation->setHistorySize(
            static_cast<unsigned int>(selEnd - selStart));
      this->ui->constellation->feed(
            data + selStart,
            static_cast<unsigned int>(selEnd - selStart));
    }
  } else {
    if (iSamp == length - 1) {
      this->ui->constellation->setHistorySize(1);
      this->ui->constellation->feed(data + iSamp, 1);
    } else if (iSamp >= 0 && iSamp < length - 1) {
      this->ui->constellation->setHistorySize(1);
      this->ui->constellation->feed(&val, 1);
    } else {
      this->ui->constellation->setHistorySize(0);
    }
  }

  this->ui->positionLabel->setText(
        Waveform::formatLabel(time, "s") + " (" + formatReal(samp) + ")");
  this->ui->iqLabel->setText(formatComplex(val));
  this->ui->magPhaseLabel->setText(
        formatReal(SU_C_ABS(val))
        + "("
        + formatReal(SU_C_ARG(val) / M_PI * 180)
        + "º)");
}

void
TimeWindow::onTogglePeriodicSelection(void)
{
  this->ui->realWaveform->setPeriodicSelection(
        this->ui->periodicSelectionCheck->isChecked());
  this->ui->imagWaveform->setPeriodicSelection(
        this->ui->periodicSelectionCheck->isChecked());

  this->ui->realWaveform->invalidate();
  this->ui->imagWaveform->invalidate();

  this->refreshUi();
}

void
TimeWindow::onPeriodicDivisionsChanged(void)
{
  this->ui->realWaveform->setDivsPerSelection(
        this->getPeriodicDivision());
  this->ui->imagWaveform->setDivsPerSelection(
        this->getPeriodicDivision());

  this->ui->realWaveform->invalidate();
  this->ui->imagWaveform->invalidate();

  this->refreshMeasures();
}

void
TimeWindow::onSaveAll(void)
{
  bool done = false;

  do {
    QFileDialog dialog(this);

    dialog.setFileMode(QFileDialog::FileMode::AnyFile);
    dialog.setAcceptMode(QFileDialog::AcceptSave);
    dialog.setWindowTitle(QString("Save capture"));
    dialog.setNameFilter(QString("MATLAB/Octave file (*.m)"));

    if (dialog.exec()) {
      QString path = dialog.selectedFiles().first();

        if (!this->exportToFile(
              path,
              0,
              static_cast<int>(this->ui->realWaveform->getDataLength()))) {
          QMessageBox::warning(
                this,
                "Cannot open file",
                "Cannote save file in the specified location. Please choose "
                "a different location and try again.",
                QMessageBox::Ok);
        } else {
          done = true;
        }
    } else {
      done = true;
    }
  } while (!done);
}

void
TimeWindow::onSaveSelection(void)
{
  bool done = false;

  do {
    QFileDialog dialog(this);

    dialog.setFileMode(QFileDialog::FileMode::AnyFile);
    dialog.setAcceptMode(QFileDialog::AcceptSave);
    dialog.setWindowTitle(QString("Save capture"));
    dialog.setNameFilter(QString("MATLAB/Octave file (*.m)"));

    if (dialog.exec()) {
      QString path = dialog.selectedFiles().first();

        if (!this->exportToFile(
              path,
              this->ui->realWaveform->getHorizontalSelectionStart(),
              this->ui->realWaveform->getHorizontalSelectionEnd())) {
          QMessageBox::warning(
                this,
                "Cannot open file",
                "Cannote save file in the specified location. Please choose "
                "a different location and try again.",
                QMessageBox::Ok);
        } else {
          done = true;
        }
    } else {
      done = true;
    }
  } while (!done);
}

void
TimeWindow::onFit(void)
{
  this->ui->realWaveform->fitToEnvelope();
  this->ui->imagWaveform->fitToEnvelope();
  this->ui->realWaveform->invalidate();
  this->ui->imagWaveform->invalidate();
}

void
TimeWindow::onToggleAutoFit(void)
{

}

void
TimeWindow::onToggleHorizontalSelection(void)
{
  if (!this->adjusting) {
    this->adjusting = true;
    this->ui->actionVertical_selection->setChecked(
          !this->ui->actionHorizontal_selection->isChecked());
    this->adjusting = false;
  }
}

void
TimeWindow::onToggleVerticalSelection(void)
{
  if (!this->adjusting) {
    this->adjusting = true;
    this->ui->actionHorizontal_selection->setChecked(
          !this->ui->actionVertical_selection->isChecked());
    this->adjusting = false;
  }
}

void
TimeWindow::onZoomToSelection(void)
{
  if (this->ui->realWaveform->getHorizontalSelectionPresent()) {
    this->ui->realWaveform->zoomHorizontal(
          static_cast<qint64>(
            this->ui->realWaveform->getHorizontalSelectionStart()),
          static_cast<qint64>(
            this->ui->realWaveform->getHorizontalSelectionEnd()));
    this->ui->imagWaveform->zoomHorizontal(
          static_cast<qint64>(
            this->ui->realWaveform->getHorizontalSelectionStart()),
          static_cast<qint64>(
            this->ui->realWaveform->getHorizontalSelectionEnd()));
    this->ui->realWaveform->invalidate();
    this->ui->imagWaveform->invalidate();
  }
}

void
TimeWindow::onZoomReset(void)
{
  // Should propagate to imaginary
  this->ui->realWaveform->zoomHorizontalReset();
  this->ui->realWaveform->zoomVerticalReset();

  this->ui->realWaveform->invalidate();
  this->ui->imagWaveform->invalidate();
}

